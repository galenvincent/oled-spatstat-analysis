sameRCP <- as.numeric(sameRCP$V1)
plot(hist(sameRCP),col=rgb(1,0,0,.5))
diffRCP <- read.table('C:/Users/galen/OneDrive/Documents/Research/parent_child/percentOut_40nmbox_manyradii_diff.csv',sep=",")
diffRCP <- as.numeric(diffRCP$V1)
p1 <- hist(sameRCP)
p2 <- hist(diffRCP)
plot(p1,col=rgb(1,0,0,.5),xlim=c(0,8),main='% Non-Overlap Area of Random Relabeled RCPs',xlab='Percent Non-Overlapping Area',ylab='Counts')
plot(p2,col=rgb(0,0,1,.5),xlim=c(0,8),add=T)
legend("topright",c('Same RCP 96 times','96 different RCPs'),col=c(rgb(1,0,0),rgb(0,0,1)),lwd=10)
text(8,650,'6% random relabeling of',pos=2)
text(8,600,'40x40x40 RCP patterns',pos=2)
text(8,500, 'One (average) small radius used',pos=2)
#####
# FROM THE HPC
sameRCP <- read.table('C:/Users/galen/OneDrive/Documents/Research/parent_child/percentOut_40nmbox_manyradii_same.csv',sep=",")
#####
# FROM THE HPC
sameRCP <- read.table('C:/Users/galen/OneDrive/Documents/Research/parent_child/percentOut_40nmbox_manyradius_same.csv',sep=",")
data <- read.csv("Public_Schools.csv)
.
help
data <- read.csv("public_schools_colorado.csv")
rm(list = ls())
data <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/public_schools_colorado.csv")
head(data)
data_rating <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/performance_sorted.csv")
head(data_rating)
"a" == "a"
data1_names <- data$NAME
data2_names <- data_rating$School.Name
data1_names[1]
data1_names[1] == data2_names[1]
data1_names[1] == data2_names[2]
View(data)
data_final <- data["NAME","LATTITUDE","LONGITUDE","ENROLLMENT","FT_TEACHER"]
data_final <- data[,{"NAME","LATTITUDE","LONGITUDE","ENROLLMENT","FT_TEACHER"}]
data_final <- data[,c("NAME","LATTITUDE","LONGITUDE","ENROLLMENT","FT_TEACHER")]
data_final <- data[,"NAME"]
data_final <- data[,c("NAME","LATTITUDE")]
names(data)
install.packages("dplyr")
library(dplyr)
install.packages("dplyr")
class(data)
myvars <- c("NAME","LATTITUDE","LONGITUDE")
data_final <- data[myvars]
myvars <- c("NAME","LATITUDE","LONGITUDE")
data_final <- data[myvars]
myvars <- c("NAME","LATITUDE","LONGITUDE","CITY","ENROLLMENT","FT_TEACHER")
data_final <- data[myvars]
head(data_final)
height(data)
size(data)
length(data)
hieght(data)
nrow(data)
data_final[,"PERFORMANCE"] <- rep(0,nrow(data))
View(data_final)
View(data_rating)
data_rating[,25]
data_rating[1,25]
data_rating[1,107]
data_rating[107,25]
data_rating[554,25]
data_final[,"PERFORMANCE"] <- rep(NaN,nrow(data))
for i in 1:nrow(data2_names){
for j in 1:nrow(data1_names){
if data2_names[i] == data1_names[j] {
data_final[j,"PERFORMANCE"] <- data_rating[i,25]
data_final[j,"CHECK"] <- data_rating[i,4]
break
}
}
}
for (i in 1:nrow(data2_names)){
for (j in 1:nrow(data1_names)){
if (data2_names[i] == data1_names[j]) {
data_final[j,"PERFORMANCE"] <- data_rating[i,25]
data_final[j,"CHECK"] <- data_rating[i,4]
break
}
}
}
data <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/public_schools_colorado.csv")
data_rating <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/performance_sorted.csv")
data1_names <- data$NAME
data2_names <- data_rating$School.Name
myvars <- c("NAME","LATITUDE","LONGITUDE","CITY","ENROLLMENT","FT_TEACHER")
data_final <- data[myvars]
data_final[,"PERFORMANCE"] <- rep(NaN,nrow(data))
for (i in 1:nrow(data2_names)){
for (j in 1:nrow(data1_names)){
if (data2_names[i] == data1_names[j]) {
data_final[j,"PERFORMANCE"] <- data_rating[i,25]
data_final[j,"CHECK"] <- data_rating[i,4]
break
}
}
}
for (i in 1:nrow(data_rating)){
for (j in 1:nrow(data_final)){
if (data2_names[i] == data1_names[j]) {
data_final[j,"PERFORMANCE"] <- data_rating[i,25]
data_final[j,"CHECK"] <- data_rating[i,4]
break
}
}
}
for (i in 1:nrow(data_rating)){
for (j in 1:nrow(data_final)){
if (data2_names[i] == data1_names[j]) {
data_final[j,"PERFORMANCE"] <- data_rating[i,25]
data_final[j,"CHECK"] <- data_rating[i,4]
break
}
}
print(i)
}
data_final2 <- data_final[!is.nan(data_final$PERFORMANCE)]
data_final2 <- data_final[!is.nan(data_final$PERFORMANCE),]
View(data_final2)
data_final2 <- data_final[!is.nan(data_final$PERFORMANCE),c(1:7)]
View(data_final2)
write.csv(data_final2, file = "C:/Users/galen/OneDrive/Desktop/Spatstat/CO_Schools_Data_final.csv")
install.packages("fields")
library(fields)
schools <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/CO_Schools_Data_Final.csv")
View(schools)
schools <- schools[,c(2,8)]
schools <- read.csv("C:/Users/galen/OneDrive/Desktop/Spatstat/CO_Schools_Data_Final.csv")
schools <- schools[,c(2:8)]
quilt.plot(schools$LATITUDE,schools$LONGITUDE,schools$PERFORMANCE,main = "Performace Ratings")
quilt.plot(schools$LATITUDE,schools$LONGITUDE,schools$PERFORMANCE,main = "Performace Ratings For Colorado Schools",xlab = "Lattitude",ylab = "Longitude")
library(fields)
schools <- read.csv("C:/Users/galen/Dropbox/MATH532F18-GalenV-JoelW/CO_Schools_Data_Final.csv")
schools <- schools[,c(2:8)]
quilt.plot(schools$LONGITUDE,schools$LATITUDE,schools$PERFORMANCE,main = "Performace Ratings For Colorado Schools",xlab = "Lattitude",ylab = "Longitude")
quilt.plot(schools$LATITUDE,schools$LONGITUDE,schools$PERFORMANCE,main = "Performace Ratings For Colorado Schools",xlab = "Lattitude",ylab = "Longitude")
quilt.plot(schools$LONGITUDE,schools$LATITUDE,schools$PERFORMANCE,main = "Performace Ratings For Colorado Schools",xlab = "Longitude",ylab = "Latitude")
rm(list=ls())
library(rapt)
?rapt
?{rapt}
# Comparing border vs trans & iso edge corrections
library(rapt)
bordRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/envelope_data/16nm box/bord.csv",sep = ",")
transRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/envelope_data/16nm box/bord.csv",sep = ",")
isoRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/envelope_data/16nm box/bord.csv",sep = ",")
bordRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
transRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
isoRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
bordRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
transRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
isoRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
#####################
# Adjusted envelope plot for this analysis
envPlotAdj <- function(tests,percentiles=c(.999),ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1]))),labels=c("Translation","Isotropic","Border")){
# tests = lists of array of values returned from the rrK3est function above
# percentiles = vector including the different percentiles you would like to see on the plot (0-1)
# do these in descending order please
color <- c(rgb(1,0,0,.5),rgb(0,1,0,.5),rgb(0,0,1,.5))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=2))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
#legend(0, ylim[2], legend=c(paste(toString(percentiles[1]*100),"% AI"), paste(toString(percentiles[2]*100),"% AI"),paste(toString(percentiles[3]*100),"% AI")),col=c(color[1],color[2],color[3]), lty=c(1,1,1), lwd=c(10,10,10))
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
legend(0,ylim[2],legend=labels,col=c(color[1],color[2],color[3]), lty=c(1,1,1),lwd=c(10,10,10))
text(1.7,2.75,paste(toString(percentiles[1]*100),"% AI"))
}
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
head(bordRRL)
View(bordRRL)
#####################
tests <- list(transRRL,bordRRL,isoRRL)
color <- c(rgb(1,0,0,.5),rgb(0,1,0,.5),rgb(0,0,1,.5))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
class(nTests)
percentiles <- c(.95)
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
128*2000
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1])))
ylim=c(-3,3)
xlim=c(0,ceiling(max(tests[[1]][,1])))
labels=c("Translation","Border","Isotropic")
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=2))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
bordRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
transRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/trans.csv",sep = ",")
isoRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/iso.csv",sep = ",")
rm(list=ls())
envPlotAdj <- function(tests,percentiles=c(.999),ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1]))),labels=c("Translation","Border","Isotropic")){
# tests = lists of array of values returned from the rrK3est function above
# percentiles = vector including the different percentiles you would like to see on the plot (0-1)
# do these in descending order please
color <- c(rgb(1,0,0,.5),rgb(0,1,0,.5),rgb(0,0,1,.5))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=2))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
#legend(0, ylim[2], legend=c(paste(toString(percentiles[1]*100),"% AI"), paste(toString(percentiles[2]*100),"% AI"),paste(toString(percentiles[3]*100),"% AI")),col=c(color[1],color[2],color[3]), lty=c(1,1,1), lwd=c(10,10,10))
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
legend(0,ylim[2],legend=labels,col=c(color[1],color[2],color[3]), lty=c(1,1,1),lwd=c(10,10,10))
text(1.7,2.75,paste(toString(percentiles[1]*100),"% AI"))
}
# Comparing border vs trans & iso edge corrections
library(rapt)
bordRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/bord.csv",sep = ",")
transRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/trans.csv",sep = ",")
isoRRL <- read.table("C:/Users/galen/OneDrive/Documents/Research/edge_corrections/16nm box/iso.csv",sep = ",")
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
text(4,2.25,"2000 RR on 16x16 box within 40x40 box")
text(4,2.25,"2000 RR on 16x16 box within 40x40 box",pos=2)
text(4,2.25,"2000 RR on 16x16 box within 40x40 box",pos=3)
text(4,2.25,"2000 RR on 16x16 box within 40x40 box",pos=4)
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
text(4,2.75,"2000 RR on 16x16 box within 40x40 box",pos=4)
text(4,2.9,"2000 RR on 16x16 box within 40x40 box",pos=4)
text(3.5,2.9,"2000 RR on 16x16 box within 40x40 box",pos=4)
text(3,2.9,"2000 RR on 16x16 box within 40x40 box",pos=4)
text(3,2.8,"2000 RR on 16x16 box within 40x40 box",pos=4)
text(3,2.7,paste(toString(percentiles[1]*100),"% AI"),pos=4)
text(3,2.5,paste(toString(percentiles[1]*100),"% AI"),pos=4)
envPlotAdj <- function(tests,percentiles=c(.999),ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1]))),labels=c("Translation","Border","Isotropic")){
# tests = lists of array of values returned from the rrK3est function above
# percentiles = vector including the different percentiles you would like to see on the plot (0-1)
# do these in descending order please
color <- c(rgb(1,0,0,.5),rgb(0,1,0,.5),rgb(0,0,1,.5))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=2))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
#legend(0, ylim[2], legend=c(paste(toString(percentiles[1]*100),"% AI"), paste(toString(percentiles[2]*100),"% AI"),paste(toString(percentiles[3]*100),"% AI")),col=c(color[1],color[2],color[3]), lty=c(1,1,1), lwd=c(10,10,10))
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
legend(0,ylim[2],legend=labels,col=c(color[1],color[2],color[3]), lty=c(1,1,1),lwd=c(10,10,10))
text(3,2.5,paste(toString(percentiles[1]*100),"% AI"),pos=4)
text(3,2.8,"2000 RR on 16x16 box within 40x40 box",pos=4)
}
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
envPlotAdj <- function(tests,percentiles=c(.999),ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1]))),labels=c("Translation","Border","Isotropic")){
# tests = lists of array of values returned from the rrK3est function above
# percentiles = vector including the different percentiles you would like to see on the plot (0-1)
# do these in descending order please
color <- c(rgb(1,0,0,.5),rgb(0,1,0,.5),rgb(0,0,1,.5))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=2))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
#legend(0, ylim[2], legend=c(paste(toString(percentiles[1]*100),"% AI"), paste(toString(percentiles[2]*100),"% AI"),paste(toString(percentiles[3]*100),"% AI")),col=c(color[1],color[2],color[3]), lty=c(1,1,1), lwd=c(10,10,10))
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
legend(0,ylim[2],legend=labels,col=c(color[1],color[2],color[3]), lty=c(1,1,1),lwd=c(10,10,10))
text(3,2.4,paste(toString(percentiles[1]*100),"% AI"),pos=4)
text(3,2.8,"2000 RR on 16x16 box within 40x40 box",pos=4)
}
envPlotAdj(list(transRRL,bordRRL,isoRRL),labels = c("Trans","Bord","Iso"),percentiles = c(.95))
# Comparing border vs trans & iso edge corrections
library(rapt)
?panomK3est
# Upload an RCP pattern
r1 <-0.0252429 #1.2 sigma
rcp_1_upload <- read.table("C:/Users/galen/Documents/Research/point_patterns/Final/FinalConfig1",sep = " ",col.names = c("x","y","z","type"))
rcp_1 <- scaleRCP(createSpat(rcp_1_upload[,c("x","y","z")]),newRadius = 0.5,oldRadius = r1)
rcp_1_upload <- read.table("C:/Users/galen/OneDrive/Documents/Research/point_patterns/Final/FinalConfig1",sep = " ",col.names = c("x","y","z","type"))
rcp_1 <- scaleRCP(createSpat(rcp_1_upload[,c("x","y","z")]),newRadius = 0.5,oldRadius = r1)
rcp <- stitch(rcp_1)
npoints(rcp)
t1 <- Sys.time()
a <- panomK3est(0.06,rcp,2000,rmax=12,correction = "bord")
t2 <- Sys.time()
t2-t1
library(parallel)
library(parallel)
t1 <- Sys.time()
a <- panomK3est(0.06,rcp,2000,rmax=12,correction = "bord")
t1 <- Sys.time()
t2 <- Sys.time
t2 <- Sys.time()
t2-t1
print(t2-t1)
t2 <- Sys.time()
print(t2-t1)
envPlotAdj <- function(tests,percentiles=c(.999),ylim=c(-3,3),xlim=c(0,ceiling(max(tests[[1]][,1])))){
# tests = lists of array of values returned from the rrK3est function above
# percentiles = vector including the different percentiles you would like to see on the plot (0-1)
# do these in descending order please
color <- palette(rainbow(length(tests)))
# break up data into r values and test results
rvals <- tests[[1]][,1]
tvals <- tests[[1]][,2:ncol(tests[[1]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
for(i in 1:length(percentiles)){
toPlotBigs[,i] <- sortedtVals[,percentileIndicesBig[i]]
toPlotSmalls[,i] <- sortedtVals[,percentileIndicesSmall[i]]
}
# plot the envelopes from the percentile data
par(oma = c(0, 2, 0, 0))
plot(rvals,tvals[,1],type="n",main="Envelopes for K Function",xlab="r",ylab="",ylim=ylim,xlim=xlim)
mtext(text=expression(sqrt('K'[3]*'(r)')*'  Anomaly'),side=2,line=0,outer=TRUE)
axis(1,at=0:xlim[2],labels=FALSE)
axis(1,at=seq(0,xlim[2],by=5))
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[1])#,border=color[i],lwd=2)
abline(h=0,lty=2,lwd=1,col="black")
#legend(0, ylim[2], legend=c(paste(toString(percentiles[1]*100),"% AI"), paste(toString(percentiles[2]*100),"% AI"),paste(toString(percentiles[3]*100),"% AI")),col=c(color[1],color[2],color[3]), lty=c(1,1,1), lwd=c(10,10,10))
for(i in 2:length(tests)){
# break up data into r values and test results
rvals <- tests[[i]][,1]
tvals <- tests[[i]][,2:ncol(tests[[i]])]
nTests <- ncol(tvals) # number of tests done
prange <- percentiles*nTests # get the range of indeces for which each percentile spans
sortedtVals <- t(apply(tvals,1,sort)) # sort the results at each r value from lowest to highest
percentileIndicesBig <- round(nTests/2)+floor(prange/2) # select the high end indexes based on being 1/2 of the percentile span from the middle of the tests
percentileIndicesSmall <- round(nTests/2)-floor(prange/2) # do the same for the low end
# grab out the columns from the sorted test results that we will plot
toPlotBigs <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotSmalls <- matrix(0,nrow=nrow(tvals),ncol=length(percentiles))
toPlotBigs[,1] <- sortedtVals[,percentileIndicesBig[1]]
toPlotSmalls[,1] <- sortedtVals[,percentileIndicesSmall[1]]
polygon(c(rvals,rev(rvals)),c(toPlotBigs[,1],rev(toPlotSmalls[,1])),col=color[i])#,border=color[i],lwd=2)
}
text(1,2.75,paste(toString(percentiles[1]*100),"% AI"))
}
library(rapt)
#####
# FROM THE HPC
sameRCP <- read.table('C:/Users/galen/OneDrive/Documents/Research/parent_child/percentOut_40nmbox_oneradius_diff.csv',sep=",")
#####
# FROM THE HPC
sameRCP <- read.table('C:/Users/galen/OneDrive/Documents/Research/parent_child/percentOut_sameRCP_manyradius_20nmbox.csv',sep=",")
sameRCP <- as.numeric(sameRCP$V1)
plot(hist(sameRCP),col=rgb(1,0,0,.5))
